// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Scrapes and notifies users of open seats
	// (GET /cron/checktrackedsections)
	CheckTrackedSections(ctx echo.Context) error
	// Cleans up any stale tracked sections
	// (GET /cron/prunetrackedsections)
	PruneTrackedSections(ctx echo.Context) error
	// Gets the list of departments at MSU
	// (GET /departments)
	GetDepartments(ctx echo.Context) error
	// Gets the courses for a department
	// (GET /departments/{departmentID}/courses)
	GetCoursesForDepartment(ctx echo.Context, departmentID string, params GetCoursesForDepartmentParams) error
	// Gets the sections for a course
	// (GET /departments/{departmentID}/courses/{courseID})
	GetSections(ctx echo.Context, departmentID string, courseID string, params GetSectionsParams) error
	// Gets general info about the web app
	// (GET /meta)
	GetMeta(ctx echo.Context) error
	// Receives SMS data
	// (POST /service/sms/receive)
	ReceiveSMS(ctx echo.Context) error
	// Gets user data for the specified user
	// (GET /user/{userID})
	GetUserData(ctx echo.Context, userID string) error
	// Updates or sets userdata for the user
	// (PUT /user/{userID})
	UpdateUserData(ctx echo.Context, userID string) error
	// Gets tracked sections for the specified user
	// (GET /user/{userID}/sections)
	GetTrackedSectionsForUser(ctx echo.Context, userID string) error
	// Adds tracked sections for the specified user
	// (PUT /user/{userID}/sections)
	AddTrackedSectionsForUser(ctx echo.Context, userID string) error
	// Removes the user from the specified section
	// (DELETE /users/{userID}/sections/{sectionID})
	RemoveTrackedSectionForUser(ctx echo.Context, userID string, sectionID string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// CheckTrackedSections converts echo context to params.
func (w *ServerInterfaceWrapper) CheckTrackedSections(ctx echo.Context) error {
	var err error

	ctx.Set(AppengineApiAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckTrackedSections(ctx)
	return err
}

// PruneTrackedSections converts echo context to params.
func (w *ServerInterfaceWrapper) PruneTrackedSections(ctx echo.Context) error {
	var err error

	ctx.Set(AppengineApiAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PruneTrackedSections(ctx)
	return err
}

// GetDepartments converts echo context to params.
func (w *ServerInterfaceWrapper) GetDepartments(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDepartments(ctx)
	return err
}

// GetCoursesForDepartment converts echo context to params.
func (w *ServerInterfaceWrapper) GetCoursesForDepartment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "departmentID" -------------
	var departmentID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "departmentID", runtime.ParamLocationPath, ctx.Param("departmentID"), &departmentID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departmentID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCoursesForDepartmentParams
	// ------------- Required query parameter "term" -------------

	err = runtime.BindQueryParameter("form", true, true, "term", ctx.QueryParams(), &params.Term)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter term: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCoursesForDepartment(ctx, departmentID, params)
	return err
}

// GetSections converts echo context to params.
func (w *ServerInterfaceWrapper) GetSections(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "departmentID" -------------
	var departmentID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "departmentID", runtime.ParamLocationPath, ctx.Param("departmentID"), &departmentID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departmentID: %s", err))
	}

	// ------------- Path parameter "courseID" -------------
	var courseID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "courseID", runtime.ParamLocationPath, ctx.Param("courseID"), &courseID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter courseID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSectionsParams
	// ------------- Required query parameter "term" -------------

	err = runtime.BindQueryParameter("form", true, true, "term", ctx.QueryParams(), &params.Term)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter term: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSections(ctx, departmentID, courseID, params)
	return err
}

// GetMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetMeta(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMeta(ctx)
	return err
}

// ReceiveSMS converts echo context to params.
func (w *ServerInterfaceWrapper) ReceiveSMS(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ReceiveSMS(ctx)
	return err
}

// GetUserData converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserData(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserData(ctx, userID)
	return err
}

// UpdateUserData converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUserData(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUserData(ctx, userID)
	return err
}

// GetTrackedSectionsForUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetTrackedSectionsForUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTrackedSectionsForUser(ctx, userID)
	return err
}

// AddTrackedSectionsForUser converts echo context to params.
func (w *ServerInterfaceWrapper) AddTrackedSectionsForUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddTrackedSectionsForUser(ctx, userID)
	return err
}

// RemoveTrackedSectionForUser converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveTrackedSectionForUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	// ------------- Path parameter "sectionID" -------------
	var sectionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sectionID", runtime.ParamLocationPath, ctx.Param("sectionID"), &sectionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sectionID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveTrackedSectionForUser(ctx, userID, sectionID)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/cron/checktrackedsections", wrapper.CheckTrackedSections)
	router.GET(baseURL+"/cron/prunetrackedsections", wrapper.PruneTrackedSections)
	router.GET(baseURL+"/departments", wrapper.GetDepartments)
	router.GET(baseURL+"/departments/:departmentID/courses", wrapper.GetCoursesForDepartment)
	router.GET(baseURL+"/departments/:departmentID/courses/:courseID", wrapper.GetSections)
	router.GET(baseURL+"/meta", wrapper.GetMeta)
	router.POST(baseURL+"/service/sms/receive", wrapper.ReceiveSMS)
	router.GET(baseURL+"/user/:userID", wrapper.GetUserData)
	router.PUT(baseURL+"/user/:userID", wrapper.UpdateUserData)
	router.GET(baseURL+"/user/:userID/sections", wrapper.GetTrackedSectionsForUser)
	router.PUT(baseURL+"/user/:userID/sections", wrapper.AddTrackedSectionsForUser)
	router.DELETE(baseURL+"/users/:userID/sections/:sectionID", wrapper.RemoveTrackedSectionForUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"3TMAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
