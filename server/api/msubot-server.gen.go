// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Scrapes and notifies users of open seats
	// (GET /cron/checktrackedsections)
	CheckTrackedSections(ctx echo.Context) error
	// Cleans up any stale tracked sections
	// (GET /cron/prunetrackedsections)
	PruneTrackedSections(ctx echo.Context) error
	// Gets the courses for a department
	// (GET /department/courses)
	GetCoursesForDepartment(ctx echo.Context, params GetCoursesForDepartmentParams) error
	// Gets the list of departments at MSU
	// (GET /departments)
	GetDepartments(ctx echo.Context) error
	// Gets general info about the web app
	// (GET /meta)
	GetMeta(ctx echo.Context) error
	// Gets the sections for a course
	// (GET /sections)
	GetSections(ctx echo.Context, params GetSectionsParams) error
	// Receives SMS data
	// (POST /service/sms/receive)
	ReceiveSMS(ctx echo.Context) error
	// Gets user data for the specified user
	// (GET /user)
	GetUserData(ctx echo.Context) error
	// Updates or sets userdata for the user
	// (PUT /user)
	UpdateUserData(ctx echo.Context) error
	// Removes the user from the specified section
	// (DELETE /user/section/{sectionID})
	RemoveTrackedSectionForUser(ctx echo.Context, sectionID string) error
	// Gets tracked sections for the specified user
	// (GET /user/sections)
	GetTrackedSectionsForUser(ctx echo.Context) error
	// Adds tracked sections for the specified user
	// (PUT /user/sections)
	AddTrackedSectionsForUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// CheckTrackedSections converts echo context to params.
func (w *ServerInterfaceWrapper) CheckTrackedSections(ctx echo.Context) error {
	var err error

	ctx.Set(AppengineApiAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckTrackedSections(ctx)
	return err
}

// PruneTrackedSections converts echo context to params.
func (w *ServerInterfaceWrapper) PruneTrackedSections(ctx echo.Context) error {
	var err error

	ctx.Set(AppengineApiAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PruneTrackedSections(ctx)
	return err
}

// GetCoursesForDepartment converts echo context to params.
func (w *ServerInterfaceWrapper) GetCoursesForDepartment(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCoursesForDepartmentParams
	// ------------- Required query parameter "term" -------------

	err = runtime.BindQueryParameter("form", true, true, "term", ctx.QueryParams(), &params.Term)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter term: %s", err))
	}

	// ------------- Required query parameter "deptAbbr" -------------

	err = runtime.BindQueryParameter("form", true, true, "deptAbbr", ctx.QueryParams(), &params.DeptAbbr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deptAbbr: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCoursesForDepartment(ctx, params)
	return err
}

// GetDepartments converts echo context to params.
func (w *ServerInterfaceWrapper) GetDepartments(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDepartments(ctx)
	return err
}

// GetMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetMeta(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMeta(ctx)
	return err
}

// GetSections converts echo context to params.
func (w *ServerInterfaceWrapper) GetSections(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSectionsParams
	// ------------- Required query parameter "term" -------------

	err = runtime.BindQueryParameter("form", true, true, "term", ctx.QueryParams(), &params.Term)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter term: %s", err))
	}

	// ------------- Required query parameter "deptAbbr" -------------

	err = runtime.BindQueryParameter("form", true, true, "deptAbbr", ctx.QueryParams(), &params.DeptAbbr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deptAbbr: %s", err))
	}

	// ------------- Required query parameter "course" -------------

	err = runtime.BindQueryParameter("form", true, true, "course", ctx.QueryParams(), &params.Course)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter course: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSections(ctx, params)
	return err
}

// ReceiveSMS converts echo context to params.
func (w *ServerInterfaceWrapper) ReceiveSMS(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ReceiveSMS(ctx)
	return err
}

// GetUserData converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserData(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserData(ctx)
	return err
}

// UpdateUserData converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUserData(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUserData(ctx)
	return err
}

// RemoveTrackedSectionForUser converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveTrackedSectionForUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sectionID" -------------
	var sectionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sectionID", runtime.ParamLocationPath, ctx.Param("sectionID"), &sectionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sectionID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveTrackedSectionForUser(ctx, sectionID)
	return err
}

// GetTrackedSectionsForUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetTrackedSectionsForUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTrackedSectionsForUser(ctx)
	return err
}

// AddTrackedSectionsForUser converts echo context to params.
func (w *ServerInterfaceWrapper) AddTrackedSectionsForUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddTrackedSectionsForUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/cron/checktrackedsections", wrapper.CheckTrackedSections)
	router.GET(baseURL+"/cron/prunetrackedsections", wrapper.PruneTrackedSections)
	router.GET(baseURL+"/department/courses", wrapper.GetCoursesForDepartment)
	router.GET(baseURL+"/departments", wrapper.GetDepartments)
	router.GET(baseURL+"/meta", wrapper.GetMeta)
	router.GET(baseURL+"/sections", wrapper.GetSections)
	router.POST(baseURL+"/service/sms/receive", wrapper.ReceiveSMS)
	router.GET(baseURL+"/user", wrapper.GetUserData)
	router.PUT(baseURL+"/user", wrapper.UpdateUserData)
	router.DELETE(baseURL+"/user/section/:sectionID", wrapper.RemoveTrackedSectionForUser)
	router.GET(baseURL+"/user/sections", wrapper.GetTrackedSectionsForUser)
	router.PUT(baseURL+"/user/sections", wrapper.AddTrackedSectionsForUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
